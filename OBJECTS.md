# Примитивные типы данных

## Памятка к домашнему заданию
Перед тем, как отправить своё решение на проверку преподавателю, сверьтесь с чеклистом

<details>
  <summary> Что делать, если возникли сложности? </summary>
  
  И это здорово! Если их преодолевать правильно, то можно получить большую образовательную пользу для себя. Периодическое возникновение вопросов, недопонимание пройденного материала - нормальная и неотъемлемая часть обучения. А мы здесь, чтобы помочь вам пройти этот путь.
  
  ### Что делать, если непонятна теория?
  1. Если подобный вопрос разбирался на лекции, посмотрите еще раз раздел с этой темой в видеозаписи.
  1. Если вопрос не решился, попробуйте поискать ответ самостоятельно в интернете, этот навык пригодится вам в работе.
  1. Если самостоятельно разобраться не удалось, задайте вопрос в общем чате, мы обязательно поможем.

  ### Что делать, если непонятно условие задания?
  1. Прежде чем задать вопрос по условию задачи, перечитайте его ещё раз и убедитесь, что в тексте условия нет прямого ответа на этот вопрос. Умение работать с текстом - важный навык работы с информацией.
  1. Если ответа на свой вопрос в тексте условия не увидели, задайте его в общем чате, мы раскроем детали условия подробнее. Не забудьте при этом скинуть и ссылку на условие задания, про которую у вас вопрос.

  ### Что делать,если не получается задача?
Если ваша проблема это **ошибка компиляции** (подчёркивает красным, не даёт запустить программу), сборки проекта, CI и прочие подобные ошибки, то:
  1. Найдите и прочитайте текст ошибки, который вам подсвечивает реплит, идея (или логи); "подчёркивает красным" - это не описание ошибки.
  1. Попробуйте понять текст ошибки, при необходимости воспользуйтесь переводчиком. Нестрашно, если вы переведёте неточно, тут главное сам процесс: со временем и с нашей помощью вы будете это делать лучше и лучше, но, пропуская этот этап, вы не сможете научиться это делать.
  1. Если не получилось понять ошибку по её тексту, попробуйте её загуглить и изучить подобную ошибку у других людей. Попробуйте примерить решения их проблем на свой код. Соотнесите найденные описания ошибки с пройденной теорией.
  1. Если все равно вашу трудности не разрешились, напишите в общий чат, обязательно указав:
      1. Название задачи и ссылку на условие
      1. Ссылку на вашу работу
      1. Текст и скриншот (не фотография) ошибки.
      1. Ваши размышления и описание шагов, которые вы совершили для решения.

Если ваша проблема это **ошибка исполнения** (программа умирает уже после запуска) или она **отрабатывает неправильно**, то:
  1. Воспользуйтесь отладчиком для пошагового анализа работы вашей программы. Так вы либо убедитесь в неправильности придуманного вами алгоритма или найдёте конкретное место, где ожидаемое поведение программы разошлось с фактическим.
  1. Если проблему найти не получилось, напишите в общий чат, обязательно указав:
      1. Название задачи и ссылку на условие
      1. Ссылку на вашу работу
      1. Конкретное и подробное описание проблемы или затруднения при решении задачи ("Помогите что не так" - это не описание)
      1. Подробное описание вашего анализа программы с помощью отладчика вместе со скринами
      1. Ваши размышления и описание шагов, которые вы совершили для решения.
  ---
  
</details>

<details>
  <summary> В решении выполнены все требования задания </summary>
  
  Убедитесь, что все требования задания выполнены. Для этого перед отправкой внимательно прочтите весь текст условия задания и соотнесите сказанное в нём с вашим решением. Навык самопроверки работы перед ревью пригодится вам как при обучении, так и на работе.

  ---
  
</details>

<details>
  <summary>Пишем в идее, сдаём в реплите</summary>
  
  Теперь вы знакомы с профессиональным редактором кода - [Intellij IDEA Community Version](https://www.jetbrains.com/idea/download/). Все задачи теперь должны выполняться в нём.
  
  Как минимум перед каждой отправкой работы на проверку (а лучше - вегда) форматируйте код. Ячейки, а именно локальные переменные, параметры, поля и тп должны быть названы камелкейсом с маленькой буквы, а классы и интерфейсы камелкейсом с большой буквы. Правила, связанные с отступами можно доверить самой идее - выберите в меню Code -> Reformat code чтобы отформатировать код в текущем файле.

  При этом задание сдаётся через [реплит](https://replit.com/). Обратите внимание на то, что на реплит ваш код следует добавлять через загрузку файлов, а не через копирование текста; при копировании и вставке кода в окно реплита форматирование может поехать. Тут алгоритм один и тот же: в пустом проекте удаляете `Main.java` (`Delete` в меню действий над файлом) и выбираете в меню что повыше пункт `Upload file` (англ. Загрузить файл) и загружаете `Main.java` с вашего компьютера из папки вашего проекта, после чего нажимаете в том же меню `Upload folder` (англ. Загрузить папку) и загружаете папки-пакеты с .java-файлами если они вам нужны. 
  
![](https://u.netology.ngcdn.ru/backend/uploads/markdown_images/image/30569/image.png)

При любой же проблеме с поведением кода теперь необходимо рассказывать про ваш анализ отладчиком вашей программы.

</details>

## Задача 1 (обязательная)
Вам предстоит разработать приложение, которое запрашивает ввод пользователем имён и после каждого введённого имени сообщает какое из всех введённых имён было самым длинным и сколько последнему введённому имени не достаёт символов до самого длинного имени.
При этом, если имя введено с маленькой буквы, оно не должно приниматься программой, а пользователю должно быть выведено об этом сообщение.

Для определения того что буква заглавная, можно использовать встроенный метод: `Character.isUpperCase(СИМВОЛ)`.

Кроме этого, после написания программы пройдитесь по ней отладчиком в идее, чтобы посмотреть как она работает изнутри. Кроме ссылки на реплит с решением прикрепите скриншот работы в отладчике с одним(!) на всю программу брейкпоинтом на условном операторе проверки длин имён и самой программой, сделавшей паузу на строке запоминания введённого имени как максимального.

Реализовав программу в идее, залейте её в реплит как показано в чеклисте выше.

## Функционал программы
1. Ввод имён
2. Проверка что первая буква заглавная
3. Если введённое имя имеет максимальную длину (среди введённых), сообщить об этом пользователю
4. Если введённое имя имеет не максимальную длину (среди введённых), сообщить пользователю самое длинное введённое имя и количество символов, насколько оно длиннее
5. Если пользователь ввёл `end`, то программа должна завершиться

### Пример 
```text
Введите имя с большой буквы:
Алексей
Это первое введённое имя!

Введите имя с большой буквы:
Пётр
Самое длинное имя: Алексей
Не хватило символов: 3

Введите имя с большой буквы:
виктор
Имена нужно вводить с большой буквы!

Введите имя с большой буквы:
Александр
Самое длинное имя: Александр
```

### Подсказки
Заведите переменную, в которой будете хранить самое длинное имя, которое вам встретилось (остальные добавляемые имена запоминать нет нужды): `String maxName = null`. Не забудьте положить туда сперва `null` - нам важно, чтобы переменная была заполнена, но пока мы не встретили ни одного имени, заполняем её временно `null`.

Заведите сканнер, поприветствуйте пользователя и начните цикл обработки имён:
```java
Scanner scanner = new Scanner(System.in);
while (true) {
    System.out.println("Введите имя с большой буквы:");
    String input = scanner.nextLine();
    if ("end".equals(input)) {
      System.out.println("Программа завершена!");
      break;
    }
    String name = input; // "переименуем" переменную, чтобы легче было работать; на этом этапе мы знаем, что ввели имя
    ...
}
```

Проверьте, что первый символ имени это большая буква (мы считаем, что пользователи вводят корректные имена и ошибиться могут только регистром первой буквы).
Для этого с помощью `name.charAt(0)` возьмите первый символ строки, а с помощью метода `Character.isUpperCase` проверьте, что это заглавная буква (этот метод в таком случае вернёт `true`).
Если введённый символ не является заглавной буквой, сообщите об этом пользователю и сделайте `continue`, чтобы перейти на следующую итерацию цикла для ввода имени сначала.

Если имя подходит и мы его встретили в первый раз, выведите об этом пользователю (`"Это первое введённое имя!"`) и сохраните ввод в переменную `maxName`. То, что пользователь ввёл имя в первый раз, можно определить по условию `maxName == null` (тк иначе там был бы уже не `null`).

Если имя не первое (т.е. `maxName` не `null`), то сравните длину введённого имени (`name.length()`) и длину запомненного самого длинного имени (`maxName.length()`). Если новое имя длиннее, запомните его (`maxName = name;`) и сообщите об этом пользователю, иначе выведите на экран самое длинное имя и сколько символов не хватает введённому чтобы быть таким же длинным (`maxName.length() - name.length()`).

Убедитесь, что всё работает, обильно протестировав свою программу и проанализировав в отладчике, если наткнулись на проблемы.

Не забудьте, что в этой работе кроме ссылки на реплит нужно отправить ещё и скриншот работы в отладчике (см. выше в условии какой именно).
